#!/usr/bin/env bash
# 
# Bootstrap is used to quickly install and setup your machine. 

# Exit if any pipeline returns a non-zero exit code
# https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#The-Set-Builtin
set -e

function main() {
    echo ''
    # This script will be inside of a folder, so change to the full dotfiles dir.
    cd "$(dirname "$0")/.."
    DOTFILES_ROOT=$(pwd -P)

    # Now we can start installing things...
    setup_gitconfig
    clone_submodules
    install_dotfiles

    echo ''
    echo 'Bootstrap script complete!'
}


function setup_gitconfig() {
    if ! [ -f git/gitconfig.local.symlink ]
    then
        __info 'Setting up .gitconfig...'
        
        # Make sure we use the correct Git Credential Helper for the current OS
        local git_credential='cache'
        if [ "$(uname -s)" == "Darwin" ]
        then
            git_credential='osxkeychain'
        fi

        # Get the user's name & email to add to the gitconfig file
        __user "Git: What is your author name?"
        read -e -r git_author_name
        __user "Git: What is your author email?"
        read -e -r git_author_email

        # Use the previous information to replace the placeholders in the example gitconfig
        sed -e "s/AUTHORNAME/$git_author_name/g" -e "s/AUTHOREMAIL/$git_author_email/g" -e "s/GIT_CREDENTIAL_HELPER/$git_credential/g" git/gitconfig.local.symlink.example > git/gitconfig.local.symlink

        __success 'Successfully created .gitconfig'
    fi
}

function clone_submodules() {
    # ZSH plugins are added to this repo using git submodules. Git submodules 
    # are not cloned when this repo is cloned, so it has to be done seperately.
    __info 'Cloning git submodules...'
    git submodule update --init --recursive > /dev/null
    __success 'Successfully cloned git submodules'

}

function link_file() {
    local source=$1 
    local destination=$2
    # Declare variables for use when the destination file already exists
    local skip=
    local overwrite= 
    local action=

    # Test if a file, dir, or link with the same name as `destination` exists
    if [[ -f "$destination" || -d "$destination" || -L "$destination" ]]
    then
        if [ "$overwrite_all" == "false" ] && [ "$skip_all" == "false" ]
        then
            # Get the actual location of the file (in case it is a symlink)
            local existingSource="$(readlink $destination)"
            # If the link is already pointing to the file we are working on, 
            # then nothing needs to happen.
            if [ "$existingSource" == "$source" ]
            then
                skip=true
            else
                # If this file is not from our dotfiles, ask the user what to do
                __info "File already exists: $destination"
                __user "Resolution Options: [s]kip, [S]kip All, [o]verwrite, or [O]verwrite All"
                read -n 1 action
                # This read wont add a newline, so lets to it manually
                printf '\n'
                
                case "$action" in
                    s ) skip=true;;
                    S ) skip_all=true;;
                    o ) overwrite=true;;
                    O ) overwrite_all=true;;
                    * ) exit 1;;
                esac
            fi
        fi

        overwrite=${overwrite:-$overwrite_all}
        skip=${skip:-$skip_all}

        if [ "$overwrite" == "true" ]
        then
            rm -rf "$destination"
            __info "Removed $destination"
        fi

        if [ "$skip" == "true" ]
        then
            __success "Skipped $destination"
        fi
    fi

    # If skip is false or empty:
    if [ "$skip" != "true" ]
    then
        ln -s "$source" "$destination"
        __success "Linked $source to $destination"
    fi
}

function install_dotfiles() {
    __info 'Installing dotfiles...'
    local overwrite_all=false skip_all=false

    # Loop through files found by the `find` function and attempt to link the file.
    for src in $(find -H "$DOTFILES_ROOT" -maxdepth 2 -name '*.symlink' -not -path '*.git*')
    do
        dst="$HOME/.$(basename "${src%.*}")"
        link_file "$src" "$dst"
    done

    __success 'Successfully installed dotfiles'
}   

function __info() {
    printf "[INFO] %s\n" "$1"
}

function __success() {
    printf "[SUCCESS] %s\n" "$1"
}

function __error() {
    printf "[ERROR] %s\n" "$1"
}

function __user() {
    printf "[QUESTION] %s\n" "$1"
    printf "    > "
}

main "$@"

