#!/usr/bin/env bash
# shellcheck disable=SC2155

set -euo pipefail
BASEDIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

main() {
    if ! on_macos && ! on_linux; then
        echo "Unsupported operating system"
        return 1
    fi

    install_packages
    setup_shell

    cd "$BASEDIR"
    echo "Downloading all git submodules"
    git submodule update --init --recursive

    run_gitconfig_setup
    run_dotbot
}

# Run the gitconfig setup script. This should be run prior to linking the gitconfig, as it creates
# the actual gitconfig file that is going to be linked.
run_gitconfig_setup() {
    "$BASEDIR/git/replace-author.sh"
}

# Use dotbot to clean dead links and symlink the dotfiles.
run_dotbot() {
    local dotbot_dir="submodules/dotbot"
    local dotbot_bin="$BASEDIR/$dotbot_dir/bin/dotbot"
    local dotbot_config="install.conf.yaml"

    git -C "$dotbot_dir" submodule sync --quiet --recursive
    "$dotbot_bin" --base-directory "$BASEDIR" --config-file "$dotbot_config"
}

# Install packages and apps. These may be packages that are requirements for other programs (e.g.
# some neovim plugins require ripgrep), or they may be things that I commonly use.
install_packages() {
    if on_macos; then
        install_macos_packages
    elif on_linux; then
        install_linux_packages
    fi
}

install_macos_packages() {
    # TODO: Automatically install homebrew if on macOS
    if ! cmd_exists "brew"; then
        echo "Homebrew is not installed"
        exit 1
    fi

    local mac_packages="$BASEDIR/packages/macos"
    local taps="$mac_packages/taps.txt"
    local formulae="$mac_packages/formulae.txt"
    local casks="$mac_packages/casks.txt"

    echo "Tapping repositories"
    while IFS="" read -r tap || [ -n "$tap" ]; do
        if should_ignore_line "$tap"; then continue; fi
        brew tap "$tap"
    done < "$taps"

    echo "Installing any missing formulae"
    while IFS="" read -r formula || [ -n "$formula" ]; do
        if should_ignore_line "$formula"; then continue; fi
        brew list "$formula" &> /dev/null || brew install "$formula"
    done < "$formulae"

    echo "Installing any missing casks"
    while IFS="" read -r cask || [ -n "$cask" ]; do
        if should_ignore_line "$cask"; then continue; fi
        brew list --cask "$cask" &> /dev/null || brew install --cask "$cask"
    done < "$casks"
}

install_linux_packages() {
    local apt_packages="$BASEDIR/packages/linux/apt.txt"

    echo "Upgrading current packages"
    sudo apt update && sudo apt upgrade -y

    echo "Installing apt packages"
    while IFS="" read -r pkg || [ -n "$pkg" ]; do
        if should_ignore_line "$pkg"; then continue; fi
        sudo apt install "$pkg" -y
    done < "$apt_packages"

    # FIXME These will currently reinstall the same version if it is already installed.
    install_gh_cli
    install_git_delta
    install_go
    install_neovim
    install_nodejs
}

# Installs the GitHub CLI using apt
# https://github.com/cli/cli/blob/trunk/docs/install_linux.md#debian-ubuntu-linux-raspberry-pi-os-apt
install_gh_cli() {
    curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
    echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
    sudo apt update
    sudo apt install gh
}

# Installs git-delta using the .deb release file
# https://dandavison.github.io/delta/installation.html
install_git_delta() {
    local arch="$(dpkg --print-architecture)"
    local repository="dandavison/delta"
    local version=$(get_latest_release "$repository")
    local release_file="git-delta_${version}_${arch}.deb"

    local tempdir="$(mktemp -d)"
    wget -P "$tempdir" "https://github.com/$repository/releases/download/$version/$release_file"
    sudo apt install "$tempdir/$release_file"

    rm -rf "$tempdir"
}

# Installs the latest version of Go using the pre-built binaries
# https://go.dev/doc/install
# https://github.com/golang/go/issues/51135#issuecomment-1036043491
install_go() {
    local arch="$(dpkg --print-architecture)"
    local release_file=$(curl "https://go.dev/dl/?mode=json" | jq -r '.[0].files[].filename | select(test("go.*.linux-'"$arch"'.tar.gz"))')
    local tempdir="$(mktemp -d)"
    wget -P "$tempdir" "https://go.dev/dl/$release_file"

    # Remove old installation and then install the new version
    sudo rm -rf /usr/local/go && sudo tar -C /usr/local -xzf "$tempdir/$release_file"
    rm -rf "$tempdir"
}

# Installs the latest release of neovim
# https://github.com/neovim/neovim/wiki/Installing-Neovim#install-from-download
install_neovim() {
    local repository="neovim/neovim"
    local version=$(get_latest_release "$repository")
    local release_file="nvim-linux64.deb"

    local tempdir="$(mktemp -d)"
    wget -P "$tempdir" "https://github.com/$repository/releases/download/$version/$release_file"
    sudo apt install "$tempdir/$release_file"

    rm -rf "$tempdir"
}

# Installs node.js using the pre-built distributions
# https://github.com/nodesource/distributions/blob/master/README.md#installation-instructions
install_nodejs() {
    curl -fsSL https://deb.nodesource.com/setup_current.x | sudo -E bash -
    sudo apt-get install -y nodejs
}

# Make sure the proper shell is the default and all dependencies are installed.
setup_shell() {
    local fish_bin=$(command -v fish)
    local shells_file="/etc/shells"

    if ! pattern_exists "$fish_bin" "$shells_file"; then
        echo "Adding fish ($fish_bin) to the list of allowed shells"
        sudo sh -c "echo $fish_bin >> $shells_file"
    fi

    if ! default_shell_is "$fish_bin"; then
        echo "Fish is not currently the default shell. Setting fish to be the default..."
        chsh -s "$fish_bin"
    fi

    if ! cmd_exists "starship"; then
        echo "Starship prompt is not installed. Installing..."
        curl -fsSL https://starship.rs/install.sh | sh -s  -- --yes
    fi

    local hushfile="$HOME/.hushlogin"
    if ! file_exists "$hushfile" ; then
        echo "Creating a hushlogin file"
        touch "$hushfile"
    fi
}

# Helper Funcs

# Returns 0 if the given command ($1) is installed/exists.
cmd_exists() {
    command -v "$1" &> /dev/null
}

# Returns 0 if the passed shell ($1) is the user's current default shell.
default_shell_is() {
    # dscl is macOS-specific
    # https://stackoverflow.com/a/41553295
    [ "$(dscl . -read "$HOME" UserShell | sed 's/UserShell: //')" == "$1" ]
}

# Returns 0 if a file exists at the given path ($1) and is a regular file.
file_exists() {
    [ -f "$1" ]
}

# Returns 0 if the script is running on macOS/Darwin.
on_macos() {
    [ "$(uname -s)" == "Darwin" ]
}

# Returns 0 if the script is running on Linux.
on_linux() {
    [ "$(uname -s)" == "Linux" ]
}

# Returns 0 if the given pattern ($1) exists in the file ($2).
pattern_exists() {
    grep -q "$1" "$2"
}

# Returns 0 if the given line ($1) should be ignored/skipped when looping through a package file.
# This skips blank lines and lines starting with '#' (used as comments).
should_ignore_line() {
    # https://stackoverflow.com/a/2172367
    [ "$1" == "" ] || [[ "$1" == \#* ]]
}

# Returns the version of the latest release for a github repo.
# https://gist.github.com/lukechilds/a83e1d7127b78fef38c2914c4ececc3c
get_latest_release() {
    curl --silent "https://api.github.com/repos/$1/releases/latest" | # Get latest release from API
        grep '"tag_name":' |                                          # Get tag line
        sed -E 's/.*"([^"]+)".*/\1/'                                  # Pluck JSON value
}

main "$@"
